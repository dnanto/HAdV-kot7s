include: "rules/common.smk"
include: "rules/target.smk"


rule files:
    params:
        auspice=Path(config.get("auspice", root_cfg / "auspice.json")),
        exclude=Path(config.get("exclude", root_cfg / "exclude.txt")),
        meta=Path(config.get("meta", root_dat / "meta.tsv")),
        coor=Path(config.get("coor", root_dat / "coor.tsv")),
        gff3=Path(config.get("gff3", root_dat / f"{group}.gff3")),
        fasta=Path(config.get("fasta", root_dat / f"{group}.fasta")),
        genbank=Path(config.get("genbank", root_dat / f"{group}.gb")),


rule extract:
    message:
        "Extract and format sequences: {wildcards.group}."
    input:
        seqs=config["seqs"],
    output:
        seqs=root_out / "{group}" / "ext.fasta",
    log:
        log=root_out / "{group}" / "ext.log",
    threads: 1
    conda:
        "envs/hadv-biopython.yaml"
    shell:
        """
        gunzip -c {input.seqs:q} || cat {input.seqs:q} | \
        sed -E -e '/^>/ s/:.*//g' -e '/^>/ s/ .*//g' -e '/^[^>]/ s/[^ACGTNacgtn-]/N/g' \
            1> {output.seqs:q} \
            2> {log.log:q}
        """


rule addmeta:
    message:
        "Calculate sequence properties: {wildcards.group}."
    input:
        seqs=rules.extract.output.seqs,
        meta=rules.files.params.meta,
    output:
        meta=root_out / "{group}" / "meta.tsv",
    log:
        log=root_out / "{group}" / "meta.log",
    threads: 1
    conda:
        "envs/hadv-biopython.yaml"
    script:
        "scripts/py/addmeta.py"


rule filter:
    message:
        "Extract, format, and filter sequences: {wildcards.group}."
    input:
        data=rules.extract.output.seqs,
        meta=rules.addmeta.output.meta,
        excl=rules.files.params.exclude,
    output:
        root_out / "{group}" / "seq.fasta",
    log:
        out=root_out / "{group}" / "seq.out.log",
        err=root_out / "{group}" / "seq.err.log",
    params:
        seed=config["seed"],
        max_dup=config["max_dup"],
        min_unk=config["min_unk"],
    threads: 1
    conda:
        "envs/hadv-augur.yaml"
    shell:
        """
        augur filter \
          --metadata {input.meta:q} \
          --sequences {input.data:q} \
          --query "unknown<={params.min_unk}" \
          --exclude {input.excl:q} \
          --exclude-where "date=?" \
          --group-by seguid \
          --sequences-per-group {params.max_dup} \
          --subsample-seed {params.seed} \
          --output {output:q} \
          1> {log.out:q} \
          2> {log.err:q}
        """


rule align:
    message:
        "Perform gene-aware multiple sequence alignment: {wildcards.group}."
    input:
        seq=rules.filter.output,
        ref=rules.files.params.fasta,
        gff=rules.files.params.gff3,
    output:
        root_out / "{group}" / "seq.aligned.fasta",
    log:
        out=root_out / "{group}" / "aln.out.log",
        err=root_out / "{group}" / "aln.err.log",
    params:
        genes=lambda wildcards, output: genes[Path(output[0]).parent.name],
        output_dir=lambda wildcards, output: Path(output[0]).parent,
        nuc_seed_length=config["nuc-seed-length"],
        nuc_seed_spacing=config["nuc-seed-spacing"],
        max_indel=config["max-indel"],
    threads: 16
    conda:
        "envs/hadv-nextalign.yaml"
    shell:
        """
        nextalign \
          --jobs {threads} \
          --in-order \
          --sequences {input.seq:q} \
          --reference {input.ref:q} \
          --genes={params.genes:q} \
          --genemap {input.gff:q} \
          --output-dir {params.output_dir:q} \
          --nuc-seed-length {params.nuc_seed_length} \
          --nuc-seed-spacing {params.nuc_seed_spacing} \
          --max-indel {params.max_indel} \
          1> {log.out:q} \
          2> {log.err:q}
        """


rule iqtree:
    message:
        "Infer maximum-likelihood tree and model of sequence evolution: {wildcards.group}."
    input:
        rules.align.output,
    output:
        root_out / "{group}" / "iqt.treefile",
    log:
        root_out / "{group}" / "iqt.log",
    params:
        seed=config["seed"],
        prefix=lambda wildcards, output: Path(output[0]).parent / "iqt",
        ufboot=config["ufboot"],
        ufjack=config["ufjack"],
    threads: 16
    conda:
        "envs/hadv-augur.yaml"
    shell:
        """
        iqtree \
          -s {input:q} \
          --seqtype DNA \
          --prefix {params.prefix:q} \
          --seed {params.seed} \
          --redo \
          -T {threads} \
          --threads-max {threads} \
          --allnni \
          --ufboot {params.ufboot} \
          --ufjack {params.ufjack} \
          --bnni \
          --abayes \
          1> /dev/null \
          2> {log:q}
        """


rule gubbins:
    message:
        "Infer maximum-likelihood tree and recombination events: {wildcards.group}."
    input:
        msa=rules.align.output,
        tree=rules.iqtree.output,
    output:
        tree=root_out / "{group}" / "gub.final_tree.tre",
        node=root_out / "{group}" / "gub.node_labelled.final_tree.tre",
        stat=root_out / "{group}" / "gub.per_branch_statistics.csv",
    log:
        out=root_out / "{group}" / "gub.out.log",
        err=root_out / "{group}" / "gub.err.log",
    params:
        tree_builder=config["tree_builder"],
        iterations=config["iterations"],
        filter_percentage=config["filter_percentage"],
        root=Path().absolute(),
        dest=lambda wildcards, output: root_out / wildcards.group / "gub",
    threads: 16
    conda:
        "envs/hadv-gubbins.yaml"
    # shadow:
    #     "shallow"
    shell:
        """
        mkdir -p {params.dest:q} && cd {params.dest:q} || exit 1 && \
        run_gubbins.py {params.root:q}/{input.msa:q} \
          --starting_tree {params.root:q}/{input.tree:q} \
          --use_time_stamp \
          --no_cleanup \
          --tree_builder {params.tree_builder} \
          --iterations {params.iterations} \
          --filter_percentage {params.filter_percentage} \
          --prefix gub \
          --threads {threads} \
          1> {params.root:q}/{log.out:q} \
          2> {params.root:q}/{log.err:q} && \
        cp gub.final_tree.tre .. 2>> {params.root:q}/{log.err:q} && \
        cp gub.node_labelled.final_tree.tre .. 2>> {params.root:q}/{log.err:q} && \
        cp gub.per_branch_statistics.csv .. 2>> {params.root:q}/{log.err:q}
        """


rule bactdate:
    message:
        "Infer recombination-aware chronogram: {wildcards.group}."
    input:
        tree=rules.gubbins.output.tree,
        node=rules.gubbins.output.node,
        stat=rules.gubbins.output.stat,
        meta=rules.addmeta.output.meta,
        fast=rules.align.output,
    output:
        tree=root_out / "{group}" / "bac.tree",
        json=root_out / "{group}" / "bac.json",
        tsv=root_out / "{group}" / "bac.tsv",
    log:
        out=root_out / "{group}" / "bac.out.log",
        msg=root_out / "{group}" / "bac.msg.log",
    params:
        models=config["models"],
        seed=config["seed"],
        reps=config["reps"],
        nbIts=config["nbIts"],
        thin=config["thin"],
        burn=config["burn"],
        ess=config["ess"],
    threads: 16
    conda:
        "envs/hadv-r.yaml"
    script:
        "scripts/R/bactdate.R"


rule mugration:
    message:
        "Infer ancestral traits: {wildcards.group}."
    input:
        tree=rules.bactdate.output.tree,
        meta=rules.addmeta.output.meta,
    output:
        root_out / "{group}" / "mug.json",
    log:
        out=root_out / "{group}" / "mug.out.log",
        err=root_out / "{group}" / "mug.err.log",
    params:
        columns="genotype clade_membership location",
    threads: 1
    conda:
        "envs/hadv-augur.yaml"
    script:
        "scripts/py/mugration.py"


rule ancestral:
    message:
        "Infer ancestral sequences: {wildcards.group}."
    input:
        tree=rules.bactdate.output.tree,
        seqs=rules.align.output,
    output:
        root_out / "{group}" / "mut.nt.json",
    log:
        out=root_out / "{group}" / "mut.nt.out.log",
        err=root_out / "{group}" / "mug.nt.err.log",
    threads: 1
    conda:
        "envs/hadv-augur.yaml"
    shell:
        """
        augur ancestral \
          --tree {input.tree:q} \
          --alignment {input.seqs:q} \
          --output-node-data {output:q} \
          1> {log.out:q} \
          2> {log.err:q}
        """


rule translate:
    message:
        "Translate gene sequences: {wildcards.group}."
    input:
        tree=rules.bactdate.output.tree,
        json=rules.ancestral.output,
        genb=rules.files.params.genbank,
    output:
        root_out / "{group}" / "mut.aa.json",
    log:
        out=root_out / "{group}" / "mut.aa.out.log",
        err=root_out / "{group}" / "mug.aa.err.log",
    threads: 1
    conda:
        "envs/hadv-augur.yaml"
    shell:
        """
        augur translate \
          --tree {input.tree:q} \
          --ancestral-sequences {input.json:q} \
          --reference-sequence {input.genb:q} \
          --output-node-data {output:q} \
          1> {log.out:q} \
          2> {log.err:q}
        """


rule auspice:
    message:
        "Export data files for auspice: {wildcards.group}."
    input:
        tree=rules.bactdate.output.tree,
        branch_lengths=rules.bactdate.output.json,
        traits=rules.mugration.output,
        mut_nt=rules.ancestral.output,
        mut_aa=rules.translate.output,
        meta=rules.addmeta.output.meta,
        coor=rules.files.params.coor,
        ausp=rules.files.params.auspice,
    output:
        root_out / "auspice" / "{group}.json",
    log:
        out=root_out / "{group}" / "aus.out.log",
        err=root_out / "{group}" / "aus.err.log",
    params:
        title=lambda wildcards, output: f"HAdV-{wildcards.group}",
    threads: 1
    conda:
        "envs/hadv-augur.yaml"
    shell:
        """
        augur export v2 \
          --tree {input.tree:q} \
          --node-data {input.branch_lengths:q} {input.traits:q} {input.mut_nt:q} {input.mut_aa:q} \
          --output {output:q} \
          --metadata {input.meta:q} \
          --auspice-config {input.ausp} \
          --lat-longs {input.coor:q} \
          --color-by-metadata genotype \
          --title {params.title:q} \
          1> {log.out:q} \
          2> {log.err:q}
        """


rule properties:
    message:
        "Output virus properties: {wildcards.group}"
    input:
        msa=rules.align.output[0],
        ref=rules.files.params.fasta,
        meta=rules.addmeta.output.meta,
    output:
        json=root_out / "{group}" / "prop.json",
    log:
        log=root_out / "{group}" / "prop.log",
    threads: 1
    conda:
        "hadv-biopython.yaml"
    script:
        "scripts/py/properties.py"


rule nextlade:
    message:
        "Assign clade to sample sequences: {wildcards.group}"
    input:
        sample=config["sample"],
        ref=rules.files.params.fasta,
        tree=rules.auspice.output,
        gff3=rules.files.params.gff3,
        qc=config["qc"],
        prop=rules.properties.output.json,
    output:
        tsv=root_out / "{group}" / "next.tsv",
    log:
        out=root_out / "{group}" / "next.out.log",
        err=root_out / "{group}" / "next.err.log",
    params:
        genes=lambda wildcards, output: genes[Path(output[0]).parent.name],
        output_dir=lambda wildcards, output: Path(output[0]).parent,
        nuc_seed_length=config["nuc-seed-length"],
        nuc_seed_spacing=config["nuc-seed-spacing"],
        max_indel=config["max-indel"],
    threads: 16
    conda:
        "hadv-biopython.yaml"
    shell:
        """
        conda run -n nextclade \
        nextclade \
          --jobs {threads} \
          --input-fasta {input.sample:q} \
          --input-root-seq {input.ref:q} \
          --input-tree {input.tree:q} \
          --genes {params.genes:q} \
          --input-gene-map {input.gff3:q} \
          --output-dir {params.output_dir:q} \
          --nuc-seed-length {params.nuc_seed_length} \
          --nuc-seed-spacing {params.nuc_seed_spacing} \
          --max-indel {params.max_indel} \
          --input-qc-config {input.qc} \
          --input-virus-properties {input.prop:q} \
          --output-tsv {output.tsv:q} \
          1> {log.out:q} \
          2> {log.err:q}
        """
